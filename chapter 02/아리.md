## 서버와 클라이언트

- HTTP 통신에서 통신하는 2대의 컴퓨터는 한쪽은 서버, 한쪽은 클라이언트가 된다.
- 클라이언트로부터 요청을 받으면 서버는 응답한다.
→ 요청 없이 응답이 발생하는 경우는 없다.

## StatelessProtocol

- http는 상태를 가지지 않는 stateless protocol이다.
- 즉, 이전에 보냈던 요청/응답 정보를 전혀 가지고있지 않다.
- 장점 : 리소스 소비가 적기 때문에 빠르다
- 상태를 가져야하는 경우라면..? → `쿠키` 이용!
ex) 자동로그인

## 쿠키

- 클라이언트 상태를 담아 서버에 보내는 방법
- 동작 방식
    - 서버가 헤더의 Set-Cookie라는 필드에 쿠키 값을 담아 보내준다.
    - 클라이언트는 쿠키 정보를 저장해뒀다가, 다음 요청시 담아 보낸다.
    - 서버는 쿠키를 확인하여 클라이언트의 상태를 알 수 있다.
- 즉, 서버에 한번도 요청을 보낸 적 없는 클라이언트라면 쿠키 정보를 알 수 없다!
- 클라이언트는 쿠키를 받아 전송만 할 뿐, 이를 생성하는 것은 서버다.

## URI를 지정하는 여러가지 방법

- 모든 정보를 request URI 에 포함한다.
- 헤더에 네트워크 위치를 포함한다.
- * 를 이용하여 서버가 자기자신에세 송신한다.

## HTTP 메소드

- GET
    - request URI로 식별된 리소스를 모두 가져온다.
    - 서버의 상태 혹은 데이터를 변화시키지 않는 경우에만 사용해야 한다
    즉, 보안상 아무 문제가 없는 데이터를 전송하더라도 서버를 변경시킬 수 있다면 사용하지 않는다.
- POST
    - 엔티티를 전송한다.
- PUT
    - 파일을 전송한다.
    - HTTP 1.1에는 인증기능이 없어 보안상의 문제로 사용하지 않는다.
    - PUT은 수정이라고 알고있는데 이 책에서 파일전송으로만 소개하는 이유는 뭘까?
- DELETE
    - 파일을 삭제한다.
- HEAD
    - GET과 같지만 바디를 돌려주지 않는다.
    - 주로 URI 유효성, 리소스 갱신 시간 등을 확인하는데 이용된다.
- OPTIONS
    - 해당 URI가 제공되는 메소드 목록 조회
- TRACE
    - 서버와 클라이언트 사이에 중간서버(프록시서버) 정보를 조회한다.
    - 크로스 사이트 트레이싱(XST) 공격에 취약하여 거의 사용하지 않는다.
- CONNECT
    - 서버와 TCP 스트림을 이용하여 터널링시킴으로써 양방향으로 연결한다.
    - 주로 암호화된 서버에 요청을 보낼 때 이용된다.

## 지속연결

- 매 요청을 보낼때마다 TCP를 이용한다면 성능이 매우 느려진다.
- 따라서 어느 한쪽이 연결을 종료할 때 까지 파이프라인화 된 연결을 이용할 수 있다.
- 장점
    - 반복되는 TCP 연결과 종료를 하지 않아도 된다.
    - 응답을 기다리지 않은채 여러 요청을 보낼 수 있다.
    - 따라서 성능이 빨라진다!